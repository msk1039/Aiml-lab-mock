from collections import deque

# State is a tuple of 9 numbers laid out row-wise
start_state = (1, 2, 3,
               4, 0, 6,
               7, 5, 8)
goal_state = (1, 2, 3,
              4, 5, 6,
              7, 8, 0)

def show_state(state):
    """Print the puzzle as a 3x3 board."""
    for row in range(0, 9, 3):
        slice_ = state[row:row + 3]
        print(" ".join(str(num) for num in slice_))


def neighbors(state):
    """Generate all states by sliding a tile into the blank."""
    zero_index = state.index(0)
    row, col = divmod(zero_index, 3)
    swaps = []
    if row > 0:
        swaps.append(zero_index - 3)
    if row < 2:
        swaps.append(zero_index + 3)
    if col > 0:
        swaps.append(zero_index - 1)
    if col < 2:
        swaps.append(zero_index + 1)

    for swap_index in swaps:
        new_state = list(state)
        new_state[zero_index], new_state[swap_index] = new_state[swap_index], new_state[zero_index]
        yield tuple(new_state)

def solve_puzzle(start, goal):
    """BFS guarantees the fewest moves solution."""
    queue = deque([start])
    parents = {start: None}

    while queue:
        current = queue.popleft()
        if current == goal:
            break
        for nxt in neighbors(current):
            if nxt not in parents:
                parents[nxt] = current
                queue.append(nxt)

    return parents

def reconstruct_moves(parents, start, goal):
    if goal not in parents:
        return []
    path = []
    current = goal
    while current is not None:
        path.append(current)
        current = parents[current]
    path.reverse()
    return path

parents = solve_puzzle(start_state, goal_state)
sequence = reconstruct_moves(parents, start_state, goal_state)

if not sequence:
    print("No solution found.")
else:
    print(f"Solved in {len(sequence) - 1} moves. States along the way:")
    for step, state in enumerate(sequence):
        print(f"\nStep {step}:")
        show_state(state)